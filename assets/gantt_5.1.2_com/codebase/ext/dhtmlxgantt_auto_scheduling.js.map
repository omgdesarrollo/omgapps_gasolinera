{"version":3,"sources":["webpack:///dhtmlxgantt_auto_scheduling.js","webpack:///webpack/bootstrap c4a39cba6e1e70e8474e","webpack:///./sources/core/links_common.js","webpack:///./sources/ext/auto_scheduling.js","webpack:///./sources/utils/helpers.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","gantt","_get_linked_task","link","getTarget","task","taskId","target","source","isTaskExists","getTask","role","assert","id","_get_link_target","_get_link_source","_formatLink","relations","this","isChildOf","isSummaryTask","from","_getImplicitLinks","respectTargetOffset","config","auto_scheduling_move_projects","targetDates","getSubtaskDates","start_date","end_date","to","$target","length","getState","drag_id","calculateDuration","fromTask","j","toTask","lag","subtaskLink","type","push","_convertToFinishToStartLink","_isAutoSchedulable","auto_scheduling","parent","selectOffset","eachTask","_getDirectDependencies","selectSuccessors","links","successors","linksIds","$source","getLink","concat","_getInheritedDependencies","stop","inheritedRelations","eachParent","apply","_getDirectSuccessors","_getInheritedSuccessors","_getDirectPredecessors","_getInheritedPredecessors","_getSuccessors","_getPredecessors","sourceTask","targetTask","res","finish_to_start","preferredStart","additionalLag","start_to_start","duration","finish_to_finish","start_to_finish","auto_scheduling_descendant_links","auto_scheduling_initial","auto_scheduling_strict","helpers","_autoSchedulingGraph","getVertices","ids","forEach","rel","vertices","sort","a","b","getGlobalTaskIndex","topologicalSort","edges","hash","$incoming","successor","S","filter","v","L","pop","node","tarjanStronglyConnectedComponents","strongConnect","vertexId","previousLink","getVertex","index","lowLink","connectedEdges","onStack","edge","w","undefined","Math","min","connectedComponent","tasks","connectedComponents","verticesHash","_autoSchedulingPath","getKey","join","getVirtualRoot","mixin","root_id","types","project","$virtual","filterDuplicates","keys","key","splice","getLinkedTasks","includePredecessors","startIds","visited","_getLinkedTasks","rootTask","visitedTasks","rootObj","chainRelations","children","getChildren","findLoops","cycles","graph","component","_autoSchedulingDateResolver","isFirstSmaller","small","big","valueOf","_hasDuration","isSmallerOrDefault","smallDate","bigDate","resolveRelationDate","getEndDate","minStart","linkId","defaultStart","relation","constraintDate","getConstraintDate","getClosestWorkTime","date","dir","predecessorEnd","successorStart","calculateEndDate","_autoSchedulingPlanner","generatePlan","getPredecessorEndDate","plan","plansHash","orderedIds","predecessorRelations","arrayMap","dateResolver","result","currentId","isLinkExists","predecessor","callEvent","applyProjectPlan","projectPlan","updateTasks","newDate","_autoSchedulingPreferredDates","startTask","Date","_autoSchedule","updateCallback","_autoscheduling_in_progress","path","updatedTasks","planner","autoSchedule","inclusive","_finalizeAutoSchedulingChanges","resetTime","batchUpdate","start","end","resetProjectDates","payload","updateTask","isCircularLink","_getConnectedGroup","manager","allRelations","findCycles","_attachAutoSchedulingHandlers","resetToStartLinksLags","skipped","originalLink","presentLinks","updatedLinks","_autoScheduleAfterLinkChange","attachEvent","predecessors","_preventCircularLink","_preventDescendantLink","_datesNotEqual","dateA","dateB","taskA","taskB","_notEqualTaskDates","task1","task2","milestone","movedTask","mode","_autoScheduleAfterDND","newTask","_lightBoxChangesHandler","oldTask","_autoschedule_lightbox_id","_lightBoxSaveHandler","getSecondsInUnit","unit","units","hour","arr","callback","workArray","slice","resArray","second","minute","day","week","month","quarter","year"],"mappings":"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","file":"dhtmlxgantt_auto_scheduling.js","sourcesContent":["/*!\n * @license\n * \n * dhtmlxGantt v.5.1.2 Professional\n * This software is covered by DHTMLX Commercial License. Usage without proper license is prohibited.\n * \n * (c) Dinamenta, UAB.\n * \n */\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */,\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(gantt) {\n// helpers for building chain of dependencies, used for critical path calculation and for auto scheduling\n\n\tgantt._get_linked_task = function (link, getTarget) {\n\t\tvar task = null;\n\t\tvar taskId = getTarget ? link.target : link.source;\n\n\t\tif (gantt.isTaskExists(taskId)) {\n\t\t\ttask = gantt.getTask(taskId);\n\t\t}\n\t\tvar role = getTarget ? \"target\" : \"source\";\n\t\tgantt.assert(task, \"Link \" + role + \" not found. Task id=\" + taskId + \", link id=\" + link.id);\n\t\treturn task;\n\t};\n\tgantt._get_link_target = function (link) {\n\t\treturn gantt._get_linked_task(link, true);\n\t};\n\n\tgantt._get_link_source = function (link) {\n\t\treturn gantt._get_linked_task(link, false);\n\t};\n\n\n\tgantt._formatLink = function (link) {\n\t\tvar relations = [];\n\t\tvar target = this._get_link_target(link);\n\t\tvar source = this._get_link_source(link);\n\n\t\tif (!(source && target)) {\n\t\t\treturn relations;\n\t\t}\n\n\t\tif ((gantt.isChildOf(source.id, target.id) && gantt.isSummaryTask(target)) || (gantt.isChildOf(target.id, source.id) && gantt.isSummaryTask(source))) {\n\t\t\treturn relations;\n\n\t\t}\n\n\n\t\t// there are three kinds of connections at this point\n\t\t// task -> task - regular link\n\t\t// task -> project - transform it into set of regular links (task -> [each subtask]), use offset beetween subtask and project dates as lag, in order not to change mutual positions of subtasks inside a project\n\t\t// project -> task - transform it into ([each subtask] -> task) links\n\t\t// project -> project - transform it into ([each subtask of p1] -> [each subtask of p2]) links\n\n\t\tvar from = this._getImplicitLinks(link, source, function (c) {\n\t\t\treturn 0;\n\t\t});\n\n\t\tvar respectTargetOffset = gantt.config.auto_scheduling_move_projects;\n\t\tvar targetDates = this.isSummaryTask(target) ? this.getSubtaskDates(target.id) : {\n\t\t\tstart_date: target.start_date,\n\t\t\tend_date: target.end_date\n\t\t};\n\t\tvar to = this._getImplicitLinks(link, target, function (c) {\n\t\t\tif (!respectTargetOffset) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\n\t\t\t\tif (!c.$target.length && !(gantt.getState().drag_id == c.id)) {// drag_id - virtual lag shouldn't restrict task that is being moved inside project\n\t\t\t\t\treturn gantt.calculateDuration({\n\t\t\t\t\t\tstart_date: targetDates.start_date,\n\t\t\t\t\t\tend_date: c.start_date,\n\t\t\t\t\t\ttask: source\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfor (var i = 0; i < from.length; i++) {\n\t\t\tvar fromTask = from[i];\n\t\t\tfor (var j = 0; j < to.length; j++) {\n\t\t\t\tvar toTask = to[j];\n\n\t\t\t\tvar lag = fromTask.lag * 1 + toTask.lag * 1;\n\n\t\t\t\tvar subtaskLink = {\n\t\t\t\t\tid: link.id,\n\t\t\t\t\ttype: link.type,\n\t\t\t\t\tsource: fromTask.task,\n\t\t\t\t\ttarget: toTask.task,\n\t\t\t\t\tlag: (link.lag * 1 || 0) + lag\n\t\t\t\t};\n\n\t\t\t\trelations.push(gantt._convertToFinishToStartLink(toTask.task, subtaskLink, source, target));\n\t\t\t}\n\t\t}\n\n\t\treturn relations;\n\t};\n\ngantt._isAutoSchedulable = function(task){\n\treturn task.auto_scheduling !== false;\n};\n\ngantt._getImplicitLinks = function(link, parent, selectOffset){\n\tvar relations = [];\n\tif(this.isSummaryTask(parent)){\n\t\tthis.eachTask(function(c){\n\t\t\tif(!this.isSummaryTask(c))\n\t\t\t\trelations.push({task: c.id, lag: selectOffset(c)});\n\t\t}, parent.id);\n\t}else{\n\t\trelations.push({task:parent.id, lag: 0});\n\t}\n\n\t\treturn relations;\n\t};\n\n\tgantt._getDirectDependencies = function (task, selectSuccessors) {\n\n\t\tvar links = [],\n\t\t\tsuccessors = [];\n\n\t\tvar linksIds = selectSuccessors ? task.$source : task.$target;\n\n\tfor(var i = 0; i < linksIds.length; i++){\n\t\tvar link = this.getLink(linksIds[i]);\n\t\tif(this.isTaskExists(link.source) && this.isTaskExists(link.target)) {\n\t\t\tvar target = this.getTask(link.target);\n\t\t\tif(this._isAutoSchedulable(target)){\n\t\t\t\tlinks.push(this.getLink(linksIds[i]));\n\t\t\t}\n\t\t}\n\t}\n\n\t\tfor (var i = 0; i < links.length; i++) {\n\t\t\tsuccessors = successors.concat(this._formatLink(links[i]));\n\t\t}\n\n\t\treturn successors;\n\t};\n\n\tgantt._getInheritedDependencies = function (task, selectSuccessors) {\n\t\tvar successors = [];\n\tvar stop = false;\n\tvar inheritedRelations = [];\n\tif(this.isTaskExists(task.id)){\n\t\tthis.eachParent(function(parent){\n\t\t\tif(stop)\n\t\t\t\treturn;\n\n\t\t\tif(this.isSummaryTask(parent)){\n\t\t\t\tif(!this._isAutoSchedulable(parent)){\n\t\t\t\t\tstop = true;\n\t\t\t\t}else{\n\t\t\t\t\tinheritedRelations.push.apply(inheritedRelations, this._getDirectDependencies(parent, selectSuccessors));\n\t\t\t\t}\n\t\t\t}\n\t\t}, task.id, this);\n\n\t\t\tfor (var i = 0; i < inheritedRelations.length; i++) {\n\n\t\t\t\tvar relProperty = selectSuccessors ? inheritedRelations[i].source : inheritedRelations[i].target;\n\n\t\t\t\tif (relProperty == task.id) {\n\t\t\t\t\tsuccessors.push(inheritedRelations[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn successors;\n\t};\n\n\n\tgantt._getDirectSuccessors = function (task) {\n\t\treturn this._getDirectDependencies(task, true);\n\t};\n\n\tgantt._getInheritedSuccessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, true);\n\t};\n\n\tgantt._getDirectPredecessors = function (task) {\n\t\treturn this._getDirectDependencies(task, false);\n\t};\n\n\tgantt._getInheritedPredecessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, false);\n\t};\n\n\n\tgantt._getSuccessors = function (task) {\n\t\treturn this._getDirectSuccessors(task).concat(this._getInheritedSuccessors(task));\n\t};\n\n\tgantt._getPredecessors = function (task) {\n\t\treturn this._getDirectPredecessors(task).concat(this._getInheritedPredecessors(task));\n\t};\n\n\n\tgantt._convertToFinishToStartLink = function (id, link, sourceTask, targetTask) {\n\t\t// convert finish-to-finish, start-to-finish and start-to-start to finish-to-start link and provide some additional properties\n\t\tvar res = {\n\t\t\ttarget: id,\n\t\t\tlink: gantt.config.links.finish_to_start,\n\t\t\tid: link.id,\n\t\t\tlag: link.lag || 0,\n\t\t\tsource: link.source,\n\t\t\tpreferredStart: null\n\t\t};\n\n\t\tvar additionalLag = 0;\n\t\tswitch (link.type) {\n\t\t\tcase gantt.config.links.start_to_start:\n\t\t\t\tadditionalLag = -sourceTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.finish_to_finish:\n\t\t\t\tadditionalLag = -targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.start_to_finish:\n\t\t\t\tadditionalLag = -sourceTask.duration - targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tadditionalLag = 0;\n\t\t}\n\n\t\tres.lag += additionalLag;\n\t\treturn res;\n\t};\n};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(3);\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(1)(gantt);\n\ngantt.config.auto_scheduling = false;\ngantt.config.auto_scheduling_descendant_links = false;\ngantt.config.auto_scheduling_initial = true;\ngantt.config.auto_scheduling_strict = false;\ngantt.config.auto_scheduling_move_projects = true;\n\n(function(){\n\nvar helpers = __webpack_require__(4);\n\n\ngantt._autoSchedulingGraph = {\n\tgetVertices: function(relations){\n\t\tvar ids = {};\n\n\t\thelpers.forEach(relations, function(rel){\n\t\t\tids[rel.target] = rel.target;\n\t\t\tids[rel.source] = rel.source;\n\t\t});\n\n\t\tvar vertices = [];\n\t\tfor(var i in ids){\n\t\t\tvertices.push(ids[i]);\n\t\t}\n\n\t\treturn vertices.sort(function(a, b){ return gantt.getGlobalTaskIndex(a) - gantt.getGlobalTaskIndex(b);});\n\t},\n\ttopologicalSort: function(edges){\n\t\tvar vertices = this.getVertices(edges);\n\t\tvar hash = {};\n\n\t\tfor(var i = 0; i < vertices.length; i ++){\n\t\t\thash[vertices[i]] = {id: vertices[i], $source:[], $target:[], $incoming: 0};\n\t\t}\n\n\t\tfor(var i = 0; i < edges.length; i++){\n\t\t\tvar successor = hash[edges[i].target];\n\t\t\tsuccessor.$target.push(i);\n\t\t\tsuccessor.$incoming = successor.$target.length;\n\t\t\thash[edges[i].source].$source.push(i);\n\n\t\t}\n\n\t\t// topological sort, Kahn's algorithm\n\t\tvar S = vertices.filter(function(v){ return !hash[v].$incoming; });\n\n\t\tvar L = [];\n\n\t\twhile(S.length){\n\t\t\tvar n = S.pop();\n\n\t\t\tL.push(n);\n\n\t\t\tvar node = hash[n];\n\n\t\t\tfor(var i = 0; i < node.$source.length; i++){\n\t\t\t\tvar m = hash[edges[node.$source[i]].target];\n\t\t\t\tm.$incoming--;\n\t\t\t\tif(!m.$incoming){\n\t\t\t\t\tS.push(m.id);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn L;\n\n\t},\n\ttarjanStronglyConnectedComponents: function(vertices, edges){\n\t\t//https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n\t\tvar verticesHash = {};\n\n\t\tvar index = 0;\n\t\tvar S = [];\n\t\tvar connectedEdges = [];\n\t\tvar connectedComponents = [];\n\n\t\thelpers.forEach(vertices, function(vertexId){\n\t\t\tvar vertex = getVertex(vertexId);\n\t\t\tif(vertex.index === undefined){\n\t\t\t\tstrongConnect(vertexId);\n\t\t\t}\n\t\t});\n\n\t\tfunction strongConnect(vertexId, previousLink){\n\t\t\tvar v = getVertex(vertexId);\n\t\t\tv.index = index;\n\t\t\tv.lowLink = index;\n\t\t\tindex++;\n\n\t\t\tif(previousLink){\n\t\t\t\tconnectedEdges.push(previousLink);\n\t\t\t}\n\n\t\t\tS.push(v);\n\t\t\tv.onStack = true;\n\n\t\t\t// Consider successors of v\n\t\t\thelpers.forEach(edges, function(edge){\n\t\t\t\tif(edge.source != vertexId) return;\n\n\t\t\t\tvar v = getVertex(edge.source);\n\t\t\t\tvar w = getVertex(edge.target);\n\t\t\t\tif(w.index === undefined){\n\t\t\t\t\t// Successor w has not yet been visited; recurse on it\n\t\t\t\t\tstrongConnect(edge.target, edge);\n\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.lowLink);\n\t\t\t\t}else if(w.onStack){\n\t\t\t\t\t// Successor w is in stack S and hence in the current SCC\n\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.index);\n\t\t\t\t\tconnectedEdges.push(edge);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t// If v is a root node, pop the stack and generate an SCC\n\t\t\tif(v.lowLink == v.index){\n\t\t\t\tvar connectedComponent = {tasks: [], links:[]};\n\t\t\t\tvar w;\n\t\t\t\tdo{\n\t\t\t\t\tvar rel = connectedEdges.pop();\n\t\t\t\t\tw = S.pop();\n\t\t\t\t\tw.onStack = false;\n\t\t\t\t\tconnectedComponent.tasks.push(w.id);\n\t\t\t\t\tif(rel){\n\t\t\t\t\t\tconnectedComponent.links.push(rel.id);\n\t\t\t\t\t}\n\t\t\t\t}while(w.id != v.id);\n\t\t\t\tconnectedComponents.push(connectedComponent);\n\t\t\t}\n\n\t\t}\n\n\t\treturn connectedComponents;\n\n\t\tfunction getVertex(id){\n\t\t\tif(!verticesHash[id]){\n\t\t\t\tverticesHash[id] = {id: id};\n\t\t\t}\n\n\t\t\treturn verticesHash[id];\n\t\t}\n\n\t}\n\n};\n\ngantt._autoSchedulingPath = {\n\tgetKey: function(rel){\n\t\treturn [rel.lag, rel.link, rel.source, rel.target].join(\"_\");\n\t},\n\tgetVirtualRoot: function(){\n\t\treturn gantt.mixin(\n\t\t\tgantt.getSubtaskDates(),\n\t\t\t{\n\t\t\t\tid: gantt.config.root_id,\n\t\t\t\ttype: gantt.config.types.project,\n\t\t\t\t$source: [],\n\t\t\t\t$target: [],\n\t\t\t\t$virtual: true\n\t\t\t}\n\t\t);\n\t},\n\n\tfilterDuplicates: function(relations){\n\t\tvar keys = {};\n\t\tfor(var i = 0; i < relations.length; i++){\n\t\t\tvar key = this.getKey(relations[i]);\n\t\t\tif(keys[key]){\n\t\t\t\trelations.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}else{\n\t\t\t\tkeys[key] = true;\n\t\t\t}\n\t\t}\n\t\treturn relations;\n\t},\n\n\tgetLinkedTasks: function(id, includePredecessors){\n\t\tvar startIds = [id];\n\n\t\tvar relations = [];\n\t\tvar visited = {};\n\t\tfor(var i = 0; i < startIds.length; i++){\n\t\t\trelations = relations.concat(this._getLinkedTasks(startIds[i], visited, includePredecessors));\n\t\t}\n\n\t\trelations = this.filterDuplicates(relations);\n\t\treturn relations;\n\t},\n\n\t_getLinkedTasks: function(rootTask, visitedTasks, includePredecessors){\n\t\tvar from = rootTask === undefined ? gantt.config.root_id : rootTask;\n\t\tvar visited = visitedTasks || {};\n\n\t\tvar rootObj = gantt.isTaskExists(from) ? gantt.getTask(from) : this.getVirtualRoot();\n\t\tvar relations = gantt._getSuccessors(rootObj);\n\n\t\tif(includePredecessors){\n\t\t\trelations.push.apply(relations, gantt._getPredecessors(rootObj));\n\t\t}\n\n\t\tvar chainRelations = [];\n\t\tfor(var i=0; i < relations.length; i++){\n\n\t\t\tif(visited[this.getKey(relations[i])])\n\t\t\t\tcontinue;\n\t\t\tvisited[this.getKey(relations[i])] = true;\n\t\t\tchainRelations = chainRelations.concat(this._getLinkedTasks(relations[i].target, visited, true));\n\t\t}\n\n\t\tvar children = gantt.getChildren(rootObj.id);\n\t\tfor(var i=0; i < children.length; i++){\n\t\t\trelations = relations.concat(this._getLinkedTasks(children[i], visited, true));\n\t\t}\n\n\t\tif(chainRelations.length){\n\t\t\trelations = relations.concat(chainRelations);\n\t\t}\n\n\t\treturn relations;\n\t},\n\n\tfindLoops: function(relations){\n\n\t\tvar cycles = [];\n\n\t\thelpers.forEach(relations, function(rel){\n\t\t\tif(rel.target == rel.source)\n\t\t\t\tcycles.push([rel.target, rel.source]);\n\t\t});\n\n\t\tvar graph =  gantt._autoSchedulingGraph;\n\t\tvar vertices = graph.getVertices(relations);\n\n\t\tvar connectedComponents = graph.tarjanStronglyConnectedComponents(vertices, relations);\n\n\t\thelpers.forEach(connectedComponents, function(component){\n\t\t\tif(component.tasks.length > 1){\n\t\t\t\tcycles.push(component);//{ tasks: [task ids], links: [links ids]}\n\t\t\t}\n\t\t});\n\n\t\treturn cycles;\n\t\t//{task:id, link:link.type, lag: link.lag || 0, source: link.source}\n\t}\n};\n\ngantt._autoSchedulingDateResolver = {\n\tisFirstSmaller: function(small, big, task){\n\t\tif(small.valueOf() < big.valueOf() && gantt._hasDuration(small, big, task))\n\t\t\treturn true;\n\t\treturn false;\n\t},\n\n\tisSmallerOrDefault: function(smallDate, bigDate, task){\n\t\treturn !!(!smallDate || this.isFirstSmaller(smallDate, bigDate, task));\n\t},\n\n\tresolveRelationDate: function(taskId, relations, getEndDate){\n\t\tvar minStart = null;\n\t\tvar linkId = null;\n\n\t\tvar defaultStart = null;\n\n\t\tfor(var i = 0; i < relations.length; i++){\n\t\t\tvar relation = relations[i];\n\t\t\ttaskId = relation.target;\n\n\t\t\tdefaultStart = relation.preferredStart;\n\n\t\t\tvar constraintDate = this.getConstraintDate(relation, getEndDate);\n\n\t\t\tif(this.isSmallerOrDefault(defaultStart, constraintDate, gantt.getTask(taskId)) && this.isSmallerOrDefault(minStart, constraintDate, gantt.getTask(taskId))){\n\t\t\t\tminStart = constraintDate;\n\t\t\t\tlinkId = relation.id;\n\t\t\t}\n\n\t\t}\n\n\t\tif(minStart){\n\t\t\tminStart = gantt.getClosestWorkTime({date:minStart, dir:\"future\", task:gantt.getTask(taskId)});\n\t\t}\n\n\t\treturn {\n\t\t\tlink: linkId,\n\t\t\ttask: taskId,\n\t\t\tstart_date: minStart\n\t\t};\n\t},\n\tgetConstraintDate: function(relation, getEndDate){\n\t\tvar predecessorEnd = getEndDate(relation.source);\n\t\tvar successor = gantt.getTask(relation.target);\n\n\t\tvar successorStart = gantt.getClosestWorkTime({date:predecessorEnd, dir:\"future\", task:successor});\n\n\t\tif(predecessorEnd && relation.lag && relation.lag*1 == relation.lag){\n\t\t\tsuccessorStart = gantt.calculateEndDate({start_date: predecessorEnd, duration: relation.lag*1, task: successor});\n\t\t}\n\n\t\treturn successorStart;\n\t}\n};\n\ngantt._autoSchedulingPlanner = {\n\tgeneratePlan: function(relations){\n\n\t\tvar graph = gantt._autoSchedulingGraph;\n\t\tvar orderedIds = graph.topologicalSort(relations);\n\t\tvar predecessorRelations = {},\n\t\t\tplansHash = {};\n\n\t\thelpers.arrayMap(orderedIds, function(v) {\n\t\t\tvar task = gantt.getTask(v);\n\t\t\tif(task.auto_scheduling === false){\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpredecessorRelations[v] = [];\n\t\t\tplansHash[v] = null;\n\t\t});\n\n\t\tfunction getPredecessorEndDate(id){\n\t\t\tvar plan = plansHash[id];\n\t\t\tvar task = gantt.getTask(id);\n\t\t\tvar res;\n\n\t\t\tif(!(plan && (plan.start_date || plan.end_date))){\n\t\t\t\tres = task.end_date;\n\t\t\t}else if(plan.end_date){\n\t\t\t\tres = plan.end_date;\n\t\t\t}else {\n\t\t\t\tres = gantt.calculateEndDate({start_date: plan.start_date, duration: task.duration, task: task});\n\t\t\t}\n\n\t\t\treturn res;\n\t\t}\n\n\t\tfor(var i = 0; i < relations.length; i++){\n\t\t\tif(predecessorRelations[relations[i].target]) {\n\t\t\t\tpredecessorRelations[relations[i].target].push(relations[i]);\n\t\t\t}\n\t\t}\n\n\t\tvar dateResolver = gantt._autoSchedulingDateResolver;\n\n\t\tvar result = [];\n\t\tfor(var i = 0; i < orderedIds.length; i++){\n\t\t\tvar currentId = orderedIds[i];\n\n\t\t\tvar plan = dateResolver.resolveRelationDate(currentId, predecessorRelations[currentId] || [], getPredecessorEndDate);\n\n\n\t\t\tif(plan.start_date && gantt.isLinkExists(plan.link)){\n\t\t\t\tvar link = gantt.getLink(plan.link);\n\t\t\t\tvar task = gantt.getTask(currentId);\n\t\t\t\tvar predecessor = gantt.getTask(link.source);\n\n\t\t\t\tif (task.start_date.valueOf() !== plan.start_date.valueOf() && gantt.callEvent(\"onBeforeTaskAutoSchedule\", [task, plan.start_date, link, predecessor]) === false) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplansHash[currentId] = plan;\n\t\t\tif(plan.start_date){\n\t\t\t\tresult.push(plan);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\tapplyProjectPlan: function(projectPlan){\n\t\tvar plan, task, link, predecessor;\n\n\t\tvar updateTasks = [];\n\t\tfor(var i = 0; i <  projectPlan.length; i++){\n\t\t\tlink = null;\n\t\t\tpredecessor = null;\n\t\t\tplan = projectPlan[i];\n\n\t\t\tif(!plan.task) continue;\n\n\t\t\ttask = gantt.getTask(plan.task);\n\t\t\tif(plan.link){\n\t\t\t\tlink = gantt.getLink(plan.link);\n\t\t\t\tpredecessor = gantt.getTask(link.source);\n\t\t\t}\n\n\t\t\tvar newDate = null;\n\t\t\tif(plan.start_date && (task.start_date.valueOf() != plan.start_date.valueOf())){\n\t\t\t\tnewDate = plan.start_date;\n\t\t\t}\n\n\t\t\tif(!newDate) continue;\n\t\t\t\n\t\t\ttask.start_date = newDate;\n\t\t\ttask.end_date = gantt.calculateEndDate(task);\n\n\t\t\tupdateTasks.push(task.id);\n\t\t\tgantt.callEvent(\"onAfterTaskAutoSchedule\", [task, newDate, link, predecessor]);\n\n\t\t}\n\t\treturn updateTasks;\n\t}\n};\n\ngantt._autoSchedulingPreferredDates = function(startTask, relations){\n\tfor(var i = 0; i < relations.length; i++){\n\t\tvar rel = relations[i];\n\t\tvar task = gantt.getTask(rel.target);\n\n\t\tif(!gantt.config.auto_scheduling_strict || rel.target == startTask){\n\t\t\trel.preferredStart = new Date(task.start_date);\n\t\t}\n\t}\n};\n\ngantt._autoSchedule = function(id, relations, updateCallback){\n\tif (gantt.callEvent(\"onBeforeAutoSchedule\", [id]) === false) {\n\t\treturn;\n\t}\n\tgantt._autoscheduling_in_progress = true;\n\n\tvar path = gantt._autoSchedulingPath;\n\n\tvar updatedTasks = [];\n\n\tvar cycles = path.findLoops(relations);\n\tif(cycles.length){\n\t\tgantt.callEvent(\"onAutoScheduleCircularLink\", [cycles]);\n\t}else{\n\n\t\tvar planner = gantt._autoSchedulingPlanner;\n\t\tgantt._autoSchedulingPreferredDates(id, relations);\n\n\t\tvar plan = planner.generatePlan(relations);\n\t\tupdatedTasks = planner.applyProjectPlan(plan);\n\n\t\tif(updateCallback){\n\t\t\tupdateCallback(updatedTasks);\n\t\t}\n\t}\n\n\tgantt._autoscheduling_in_progress = false;\n\tgantt.callEvent(\"onAfterAutoSchedule\", [id, updatedTasks]);\n\n\treturn updatedTasks;\n};\n\ngantt.autoSchedule = function(id, inclusive){\n\n\tif(inclusive === undefined){\n\t\tinclusive = true;\n\t}else{\n\t\tinclusive = !!inclusive;\n\t}\n\tvar relations =  gantt._autoSchedulingPath.getLinkedTasks(id, inclusive);\n\tgantt._autoSchedule(id, relations, gantt._finalizeAutoSchedulingChanges);\n};\n\ngantt._finalizeAutoSchedulingChanges = function(updatedTasks){\n\tfunction resetTime(task){\n\t\tif(batchUpdate)\n\t\t\treturn;\n\n\t\tvar start = task.start_date.valueOf(),\n\t\t\tend = task.end_date.valueOf();\n\n\t\tgantt.resetProjectDates(task);\n\t\tif(task.start_date.valueOf() != start || task.end_date.valueOf() != end){\n\t\t\tbatchUpdate = true;\n\t\t\treturn;\n\t\t}\n\t\tvar children = gantt.getChildren(task.id);\n\t\tfor(var i = 0; !batchUpdate && i < children.length; i++){\n\t\t\tresetTime(gantt.getTask(children[i]));\n\t\t}\n\t}\n\n\tvar batchUpdate = false;\n\t// call batchUpdate (full repaint) only if we update multiple tasks,\n\tif(updatedTasks.length == 1){\n\t\tgantt.eachParent(resetTime, updatedTasks[0]);\n\t}else if(updatedTasks.length){\n\t\tbatchUpdate = true;\n\t}\n\n\tfunction payload(){\n\t\tfor(var i = 0; i < updatedTasks.length; i++){\n\t\t\tgantt.updateTask(updatedTasks[i]);\n\t\t}\n\t}\n\tif(batchUpdate){\n\t\tgantt.batchUpdate(payload);\n\t}else{\n\t\tpayload();\n\t}\n\n};\n\ngantt.isCircularLink = function(link){\n\treturn !!gantt._getConnectedGroup(link);\n\n};\n\ngantt._getConnectedGroup = function(link){\n\tvar manager = gantt._autoSchedulingPath;\n\n\tvar allRelations = manager.getLinkedTasks();\n\tif(!gantt.isLinkExists(link.id)){\n\t\tallRelations = allRelations.concat(gantt._formatLink(link));\n\t}\n\n\tvar cycles = manager.findLoops(allRelations);\n\n\tvar found = false;\n\tfor(var i = 0; (i < cycles.length) && !found; i++){\n\t\tvar links = cycles[i].links;\n\t\tfor(var j = 0; j < links.length; j++){\n\t\t\tif(links[j] == link.id){\n\t\t\t\treturn cycles[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n};\n\ngantt.findCycles = function(){\n\tvar manager = gantt._autoSchedulingPath;\n\n\tvar allRelations = manager.getLinkedTasks();\n\treturn manager.findLoops(allRelations);\n};\n\ngantt._attachAutoSchedulingHandlers = function(){\n\n\tgantt._autoScheduleAfterLinkChange = function (linkId, link) {\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\n\t\t\tgantt.autoSchedule(link.source);\n\t\t}\n\t};\n\n\tgantt.attachEvent(\"onAfterLinkUpdate\", gantt._autoScheduleAfterLinkChange);\n\tgantt.attachEvent(\"onAfterLinkAdd\", gantt._autoScheduleAfterLinkChange);\n\n\tgantt.attachEvent(\"onAfterLinkDelete\", function(id, link){\n\t\tif (this.config.auto_scheduling && !this._autoscheduling_in_progress && this.isTaskExists(link.target)) {\n\t\t\t// after link deleted - auto schedule target for other relations that may be left\n\t\t\tvar target = this.getTask(link.target);\n\t\t\tvar predecessors = this._getPredecessors(target);\n\t\t\tif(predecessors.length){\n\t\t\t\tthis.autoSchedule(predecessors[0].source, false);\n\t\t\t}\n\t\t}\n\t});\n\n\tgantt.attachEvent(\"onParse\", function(){\n\t\tif (gantt.config.auto_scheduling && gantt.config.auto_scheduling_initial) {\n\t\t\tgantt.autoSchedule();\n\t\t}\n\t});\n\n\tgantt._preventCircularLink = function(id, link){\n\t\tif(gantt.isCircularLink(link)){\n\t\t\tgantt.callEvent(\"onCircularLinkError\", [link, gantt._getConnectedGroup(link)]);\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t};\n\n\tgantt._preventDescendantLink = function(id, link){\n\t\tvar source = gantt.getTask(link.source),\n\t\t\ttarget = gantt.getTask(link.target);\n\n\t\tif(!gantt.config.auto_scheduling_descendant_links){\n\t\t\tif((gantt.isChildOf(source.id, target.id) && gantt.isSummaryTask(target)) || (gantt.isChildOf(target.id, source.id) && gantt.isSummaryTask(source))){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\tgantt.attachEvent(\"onBeforeLinkAdd\", gantt._preventCircularLink);\n\tgantt.attachEvent(\"onBeforeLinkAdd\", gantt._preventDescendantLink);\n\tgantt.attachEvent(\"onBeforeLinkUpdate\", gantt._preventCircularLink);\n\tgantt.attachEvent(\"onBeforeLinkUpdate\", gantt._preventDescendantLink);\n\n\tgantt._datesNotEqual = function(dateA, dateB, taskA, taskB){\n\t\tif(dateA.valueOf() > dateB.valueOf()){\n\t\t\treturn this._hasDuration({start_date: dateB, end_date: dateA, task: taskB});\n\t\t}else{\n\t\t\treturn this._hasDuration({start_date: dateA, end_date: dateB, task: taskA});\n\t\t}\n\t};\n\tgantt._notEqualTaskDates = function(task1, task2){\n\t\tif (this._datesNotEqual(task1.start_date, task2.start_date, task1, task2) ||\n\t\t\t((this._datesNotEqual(task1.end_date, task2.end_date, task1, task2) ||\n\t\t\t\ttask1.duration != task2.duration) && task1.type != gantt.config.types.milestone)) {\n\t\t\treturn true;\n\t\t}\n\t};\n\n\tvar relations;\n\tvar movedTask;\n\tgantt.attachEvent(\"onBeforeTaskDrag\", function(id, mode, task){\n\t\tif(gantt.config.auto_scheduling_move_projects){\n\t\t\t// collect relations before drag and drop  in order to have original positions of subtasks within project since they are used as lag when moving dependent project\n\t\t\trelations = gantt._autoSchedulingPath.getLinkedTasks(id, true);\n\t\t\tmovedTask = id;\n\t\t}\n\t\treturn true;\n\t});\n\n\tfunction resetToStartLinksLags(taskId, relations){\n\t\tvar skipped = false;\n\t\tfor(var i = 0; i < relations.length; i++){\n\t\t\tvar originalLink = gantt.getLink(relations[i].id);\n\t\t\tif(originalLink.type == gantt.config.links.start_to_start || originalLink.type == gantt.config.links.start_to_finish){\n\t\t\t\trelations.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t\tskipped = true;\n\t\t\t}\n\t\t}\n\n\t\tif(skipped){\n\t\t\tvar presentLinks = {};\n\t\t\tfor(var i = 0; i < relations.length; i++){\n\t\t\t\tpresentLinks[relations[i].id] = true;\n\t\t\t}\n\n\t\t\tvar updatedLinks = gantt._autoSchedulingPath.getLinkedTasks(taskId, true);\n\t\t\tfor(var i = 0; i < updatedLinks.length; i++){\n\t\t\t\tif(!presentLinks[updatedLinks[i].id]){\n\t\t\t\t\trelations.push(updatedLinks[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgantt._autoScheduleAfterDND = function(taskId, task){\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\n\t\t\tvar newTask = this.getTask(taskId);\n\t\t\tif (gantt._notEqualTaskDates(task, newTask)){\n\t\t\t\tif(gantt.config.auto_scheduling_move_projects && movedTask == taskId){\n\n\t\t\t\t\tif(gantt.calculateDuration(task) != gantt.calculateDuration(newTask)){\n\t\t\t\t\t\t// task duration is used as lag when converting start_to_start and start_to_finish into finish to start links\n\t\t\t\t\t\t// recalculate these links if task duration has changed\n\t\t\t\t\t\tresetToStartLinksLags(taskId, relations);\n\t\t\t\t\t}\n\n\n\t\t\t\t\tgantt._autoSchedule(taskId, relations, gantt._finalizeAutoSchedulingChanges);\n\t\t\t\t}else{\n\t\t\t\t\tgantt.autoSchedule(newTask.id);\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t}\n\t\trelations = null;\n\t\tmovedTask = null;\n\t\treturn true;\n\t};\n\n\tgantt._lightBoxChangesHandler = function (taskId, task) {\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\n\t\t\tvar oldTask = this.getTask(taskId);\n\t\t\tif (gantt._notEqualTaskDates(task, oldTask)) {\n\t\t\t\tgantt._autoschedule_lightbox_id = taskId;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\tgantt._lightBoxSaveHandler = function (taskId, task) {\n\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\n\t\t\tif (gantt._autoschedule_lightbox_id && gantt._autoschedule_lightbox_id == taskId) {\n\t\t\t\tgantt._autoschedule_lightbox_id = null;\n\t\t\t\tgantt.autoSchedule(task.id);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\n\n\n\tgantt.attachEvent(\"onBeforeTaskChanged\", function(id, mode, task){ return gantt._autoScheduleAfterDND(id, task); });\n\tgantt.attachEvent(\"onLightboxSave\", gantt._lightBoxChangesHandler);\n\tgantt.attachEvent(\"onAfterTaskUpdate\", gantt._lightBoxSaveHandler);\n\n\n};\n\n\ngantt.attachEvent(\"onGanttReady\", function(){\n\tgantt._attachAutoSchedulingHandlers();\n\t// attach handlers only when initialized for the first time\n\tgantt._attachAutoSchedulingHandlers = function(){};\n});\n\n})();\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\nvar units = {\n\t\"second\": 1,\n\t\"minute\": 60,\n\t\"hour\": 60 * 60,\n\t\"day\": 60 * 60 * 24,\n\t\"week\": 60 * 60 * 24 * 7,\n\t\"month\": 60 * 60 * 24 * 30,\n\t\"quarter\": 60 * 60 * 24 * 30 * 3,\n\t\"year\": 60 * 60 * 24 * 365\n};\nfunction getSecondsInUnit(unit){\n\treturn units[unit] || units.hour;\n}\n\nfunction forEach(arr, callback){\n\tvar workArray = arr.slice();\n\tfor(var i = 0; i < workArray.length; i++){\n\t\tcallback(workArray[i], i);\n\t}\n}\n\nfunction arrayMap(arr, callback){\n\tvar workArray = arr.slice();\n\tvar resArray = [];\n\n\tfor(var i = 0; i < workArray.length; i++){\n\t\tresArray.push(callback(workArray[i], i));\n\t}\n\n\treturn resArray;\n}\n\nmodule.exports = {\n\tgetSecondsInUnit: getSecondsInUnit,\n\tforEach: forEach,\n\tarrayMap: arrayMap\n};\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// dhtmlxgantt_auto_scheduling.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c4a39cba6e1e70e8474e","module.exports = function(gantt) {\n// helpers for building chain of dependencies, used for critical path calculation and for auto scheduling\n\n\tgantt._get_linked_task = function (link, getTarget) {\n\t\tvar task = null;\n\t\tvar taskId = getTarget ? link.target : link.source;\n\n\t\tif (gantt.isTaskExists(taskId)) {\n\t\t\ttask = gantt.getTask(taskId);\n\t\t}\n\t\tvar role = getTarget ? \"target\" : \"source\";\n\t\tgantt.assert(task, \"Link \" + role + \" not found. Task id=\" + taskId + \", link id=\" + link.id);\n\t\treturn task;\n\t};\n\tgantt._get_link_target = function (link) {\n\t\treturn gantt._get_linked_task(link, true);\n\t};\n\n\tgantt._get_link_source = function (link) {\n\t\treturn gantt._get_linked_task(link, false);\n\t};\n\n\n\tgantt._formatLink = function (link) {\n\t\tvar relations = [];\n\t\tvar target = this._get_link_target(link);\n\t\tvar source = this._get_link_source(link);\n\n\t\tif (!(source && target)) {\n\t\t\treturn relations;\n\t\t}\n\n\t\tif ((gantt.isChildOf(source.id, target.id) && gantt.isSummaryTask(target)) || (gantt.isChildOf(target.id, source.id) && gantt.isSummaryTask(source))) {\n\t\t\treturn relations;\n\n\t\t}\n\n\n\t\t// there are three kinds of connections at this point\n\t\t// task -> task - regular link\n\t\t// task -> project - transform it into set of regular links (task -> [each subtask]), use offset beetween subtask and project dates as lag, in order not to change mutual positions of subtasks inside a project\n\t\t// project -> task - transform it into ([each subtask] -> task) links\n\t\t// project -> project - transform it into ([each subtask of p1] -> [each subtask of p2]) links\n\n\t\tvar from = this._getImplicitLinks(link, source, function (c) {\n\t\t\treturn 0;\n\t\t});\n\n\t\tvar respectTargetOffset = gantt.config.auto_scheduling_move_projects;\n\t\tvar targetDates = this.isSummaryTask(target) ? this.getSubtaskDates(target.id) : {\n\t\t\tstart_date: target.start_date,\n\t\t\tend_date: target.end_date\n\t\t};\n\t\tvar to = this._getImplicitLinks(link, target, function (c) {\n\t\t\tif (!respectTargetOffset) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\n\t\t\t\tif (!c.$target.length && !(gantt.getState().drag_id == c.id)) {// drag_id - virtual lag shouldn't restrict task that is being moved inside project\n\t\t\t\t\treturn gantt.calculateDuration({\n\t\t\t\t\t\tstart_date: targetDates.start_date,\n\t\t\t\t\t\tend_date: c.start_date,\n\t\t\t\t\t\ttask: source\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfor (var i = 0; i < from.length; i++) {\n\t\t\tvar fromTask = from[i];\n\t\t\tfor (var j = 0; j < to.length; j++) {\n\t\t\t\tvar toTask = to[j];\n\n\t\t\t\tvar lag = fromTask.lag * 1 + toTask.lag * 1;\n\n\t\t\t\tvar subtaskLink = {\n\t\t\t\t\tid: link.id,\n\t\t\t\t\ttype: link.type,\n\t\t\t\t\tsource: fromTask.task,\n\t\t\t\t\ttarget: toTask.task,\n\t\t\t\t\tlag: (link.lag * 1 || 0) + lag\n\t\t\t\t};\n\n\t\t\t\trelations.push(gantt._convertToFinishToStartLink(toTask.task, subtaskLink, source, target));\n\t\t\t}\n\t\t}\n\n\t\treturn relations;\n\t};\n\ngantt._isAutoSchedulable = function(task){\n\treturn task.auto_scheduling !== false;\n};\n\ngantt._getImplicitLinks = function(link, parent, selectOffset){\n\tvar relations = [];\n\tif(this.isSummaryTask(parent)){\n\t\tthis.eachTask(function(c){\n\t\t\tif(!this.isSummaryTask(c))\n\t\t\t\trelations.push({task: c.id, lag: selectOffset(c)});\n\t\t}, parent.id);\n\t}else{\n\t\trelations.push({task:parent.id, lag: 0});\n\t}\n\n\t\treturn relations;\n\t};\n\n\tgantt._getDirectDependencies = function (task, selectSuccessors) {\n\n\t\tvar links = [],\n\t\t\tsuccessors = [];\n\n\t\tvar linksIds = selectSuccessors ? task.$source : task.$target;\n\n\tfor(var i = 0; i < linksIds.length; i++){\n\t\tvar link = this.getLink(linksIds[i]);\n\t\tif(this.isTaskExists(link.source) && this.isTaskExists(link.target)) {\n\t\t\tvar target = this.getTask(link.target);\n\t\t\tif(this._isAutoSchedulable(target)){\n\t\t\t\tlinks.push(this.getLink(linksIds[i]));\n\t\t\t}\n\t\t}\n\t}\n\n\t\tfor (var i = 0; i < links.length; i++) {\n\t\t\tsuccessors = successors.concat(this._formatLink(links[i]));\n\t\t}\n\n\t\treturn successors;\n\t};\n\n\tgantt._getInheritedDependencies = function (task, selectSuccessors) {\n\t\tvar successors = [];\n\tvar stop = false;\n\tvar inheritedRelations = [];\n\tif(this.isTaskExists(task.id)){\n\t\tthis.eachParent(function(parent){\n\t\t\tif(stop)\n\t\t\t\treturn;\n\n\t\t\tif(this.isSummaryTask(parent)){\n\t\t\t\tif(!this._isAutoSchedulable(parent)){\n\t\t\t\t\tstop = true;\n\t\t\t\t}else{\n\t\t\t\t\tinheritedRelations.push.apply(inheritedRelations, this._getDirectDependencies(parent, selectSuccessors));\n\t\t\t\t}\n\t\t\t}\n\t\t}, task.id, this);\n\n\t\t\tfor (var i = 0; i < inheritedRelations.length; i++) {\n\n\t\t\t\tvar relProperty = selectSuccessors ? inheritedRelations[i].source : inheritedRelations[i].target;\n\n\t\t\t\tif (relProperty == task.id) {\n\t\t\t\t\tsuccessors.push(inheritedRelations[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn successors;\n\t};\n\n\n\tgantt._getDirectSuccessors = function (task) {\n\t\treturn this._getDirectDependencies(task, true);\n\t};\n\n\tgantt._getInheritedSuccessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, true);\n\t};\n\n\tgantt._getDirectPredecessors = function (task) {\n\t\treturn this._getDirectDependencies(task, false);\n\t};\n\n\tgantt._getInheritedPredecessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, false);\n\t};\n\n\n\tgantt._getSuccessors = function (task) {\n\t\treturn this._getDirectSuccessors(task).concat(this._getInheritedSuccessors(task));\n\t};\n\n\tgantt._getPredecessors = function (task) {\n\t\treturn this._getDirectPredecessors(task).concat(this._getInheritedPredecessors(task));\n\t};\n\n\n\tgantt._convertToFinishToStartLink = function (id, link, sourceTask, targetTask) {\n\t\t// convert finish-to-finish, start-to-finish and start-to-start to finish-to-start link and provide some additional properties\n\t\tvar res = {\n\t\t\ttarget: id,\n\t\t\tlink: gantt.config.links.finish_to_start,\n\t\t\tid: link.id,\n\t\t\tlag: link.lag || 0,\n\t\t\tsource: link.source,\n\t\t\tpreferredStart: null\n\t\t};\n\n\t\tvar additionalLag = 0;\n\t\tswitch (link.type) {\n\t\t\tcase gantt.config.links.start_to_start:\n\t\t\t\tadditionalLag = -sourceTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.finish_to_finish:\n\t\t\t\tadditionalLag = -targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.start_to_finish:\n\t\t\t\tadditionalLag = -sourceTask.duration - targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tadditionalLag = 0;\n\t\t}\n\n\t\tres.lag += additionalLag;\n\t\treturn res;\n\t};\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/core/links_common.js\n// module id = 1\n// module chunks = 1 3","require(\"../core/links_common\")(gantt);\n\ngantt.config.auto_scheduling = false;\ngantt.config.auto_scheduling_descendant_links = false;\ngantt.config.auto_scheduling_initial = true;\ngantt.config.auto_scheduling_strict = false;\ngantt.config.auto_scheduling_move_projects = true;\n\n(function(){\n\nvar helpers = require(\"../utils/helpers\");\n\n\ngantt._autoSchedulingGraph = {\n\tgetVertices: function(relations){\n\t\tvar ids = {};\n\n\t\thelpers.forEach(relations, function(rel){\n\t\t\tids[rel.target] = rel.target;\n\t\t\tids[rel.source] = rel.source;\n\t\t});\n\n\t\tvar vertices = [];\n\t\tfor(var i in ids){\n\t\t\tvertices.push(ids[i]);\n\t\t}\n\n\t\treturn vertices.sort(function(a, b){ return gantt.getGlobalTaskIndex(a) - gantt.getGlobalTaskIndex(b);});\n\t},\n\ttopologicalSort: function(edges){\n\t\tvar vertices = this.getVertices(edges);\n\t\tvar hash = {};\n\n\t\tfor(var i = 0; i < vertices.length; i ++){\n\t\t\thash[vertices[i]] = {id: vertices[i], $source:[], $target:[], $incoming: 0};\n\t\t}\n\n\t\tfor(var i = 0; i < edges.length; i++){\n\t\t\tvar successor = hash[edges[i].target];\n\t\t\tsuccessor.$target.push(i);\n\t\t\tsuccessor.$incoming = successor.$target.length;\n\t\t\thash[edges[i].source].$source.push(i);\n\n\t\t}\n\n\t\t// topological sort, Kahn's algorithm\n\t\tvar S = vertices.filter(function(v){ return !hash[v].$incoming; });\n\n\t\tvar L = [];\n\n\t\twhile(S.length){\n\t\t\tvar n = S.pop();\n\n\t\t\tL.push(n);\n\n\t\t\tvar node = hash[n];\n\n\t\t\tfor(var i = 0; i < node.$source.length; i++){\n\t\t\t\tvar m = hash[edges[node.$source[i]].target];\n\t\t\t\tm.$incoming--;\n\t\t\t\tif(!m.$incoming){\n\t\t\t\t\tS.push(m.id);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn L;\n\n\t},\n\ttarjanStronglyConnectedComponents: function(vertices, edges){\n\t\t//https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n\t\tvar verticesHash = {};\n\n\t\tvar index = 0;\n\t\tvar S = [];\n\t\tvar connectedEdges = [];\n\t\tvar connectedComponents = [];\n\n\t\thelpers.forEach(vertices, function(vertexId){\n\t\t\tvar vertex = getVertex(vertexId);\n\t\t\tif(vertex.index === undefined){\n\t\t\t\tstrongConnect(vertexId);\n\t\t\t}\n\t\t});\n\n\t\tfunction strongConnect(vertexId, previousLink){\n\t\t\tvar v = getVertex(vertexId);\n\t\t\tv.index = index;\n\t\t\tv.lowLink = index;\n\t\t\tindex++;\n\n\t\t\tif(previousLink){\n\t\t\t\tconnectedEdges.push(previousLink);\n\t\t\t}\n\n\t\t\tS.push(v);\n\t\t\tv.onStack = true;\n\n\t\t\t// Consider successors of v\n\t\t\thelpers.forEach(edges, function(edge){\n\t\t\t\tif(edge.source != vertexId) return;\n\n\t\t\t\tvar v = getVertex(edge.source);\n\t\t\t\tvar w = getVertex(edge.target);\n\t\t\t\tif(w.index === undefined){\n\t\t\t\t\t// Successor w has not yet been visited; recurse on it\n\t\t\t\t\tstrongConnect(edge.target, edge);\n\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.lowLink);\n\t\t\t\t}else if(w.onStack){\n\t\t\t\t\t// Successor w is in stack S and hence in the current SCC\n\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.index);\n\t\t\t\t\tconnectedEdges.push(edge);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t// If v is a root node, pop the stack and generate an SCC\n\t\t\tif(v.lowLink == v.index){\n\t\t\t\tvar connectedComponent = {tasks: [], links:[]};\n\t\t\t\tvar w;\n\t\t\t\tdo{\n\t\t\t\t\tvar rel = connectedEdges.pop();\n\t\t\t\t\tw = S.pop();\n\t\t\t\t\tw.onStack = false;\n\t\t\t\t\tconnectedComponent.tasks.push(w.id);\n\t\t\t\t\tif(rel){\n\t\t\t\t\t\tconnectedComponent.links.push(rel.id);\n\t\t\t\t\t}\n\t\t\t\t}while(w.id != v.id);\n\t\t\t\tconnectedComponents.push(connectedComponent);\n\t\t\t}\n\n\t\t}\n\n\t\treturn connectedComponents;\n\n\t\tfunction getVertex(id){\n\t\t\tif(!verticesHash[id]){\n\t\t\t\tverticesHash[id] = {id: id};\n\t\t\t}\n\n\t\t\treturn verticesHash[id];\n\t\t}\n\n\t}\n\n};\n\ngantt._autoSchedulingPath = {\n\tgetKey: function(rel){\n\t\treturn [rel.lag, rel.link, rel.source, rel.target].join(\"_\");\n\t},\n\tgetVirtualRoot: function(){\n\t\treturn gantt.mixin(\n\t\t\tgantt.getSubtaskDates(),\n\t\t\t{\n\t\t\t\tid: gantt.config.root_id,\n\t\t\t\ttype: gantt.config.types.project,\n\t\t\t\t$source: [],\n\t\t\t\t$target: [],\n\t\t\t\t$virtual: true\n\t\t\t}\n\t\t);\n\t},\n\n\tfilterDuplicates: function(relations){\n\t\tvar keys = {};\n\t\tfor(var i = 0; i < relations.length; i++){\n\t\t\tvar key = this.getKey(relations[i]);\n\t\t\tif(keys[key]){\n\t\t\t\trelations.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}else{\n\t\t\t\tkeys[key] = true;\n\t\t\t}\n\t\t}\n\t\treturn relations;\n\t},\n\n\tgetLinkedTasks: function(id, includePredecessors){\n\t\tvar startIds = [id];\n\n\t\tvar relations = [];\n\t\tvar visited = {};\n\t\tfor(var i = 0; i < startIds.length; i++){\n\t\t\trelations = relations.concat(this._getLinkedTasks(startIds[i], visited, includePredecessors));\n\t\t}\n\n\t\trelations = this.filterDuplicates(relations);\n\t\treturn relations;\n\t},\n\n\t_getLinkedTasks: function(rootTask, visitedTasks, includePredecessors){\n\t\tvar from = rootTask === undefined ? gantt.config.root_id : rootTask;\n\t\tvar visited = visitedTasks || {};\n\n\t\tvar rootObj = gantt.isTaskExists(from) ? gantt.getTask(from) : this.getVirtualRoot();\n\t\tvar relations = gantt._getSuccessors(rootObj);\n\n\t\tif(includePredecessors){\n\t\t\trelations.push.apply(relations, gantt._getPredecessors(rootObj));\n\t\t}\n\n\t\tvar chainRelations = [];\n\t\tfor(var i=0; i < relations.length; i++){\n\n\t\t\tif(visited[this.getKey(relations[i])])\n\t\t\t\tcontinue;\n\t\t\tvisited[this.getKey(relations[i])] = true;\n\t\t\tchainRelations = chainRelations.concat(this._getLinkedTasks(relations[i].target, visited, true));\n\t\t}\n\n\t\tvar children = gantt.getChildren(rootObj.id);\n\t\tfor(var i=0; i < children.length; i++){\n\t\t\trelations = relations.concat(this._getLinkedTasks(children[i], visited, true));\n\t\t}\n\n\t\tif(chainRelations.length){\n\t\t\trelations = relations.concat(chainRelations);\n\t\t}\n\n\t\treturn relations;\n\t},\n\n\tfindLoops: function(relations){\n\n\t\tvar cycles = [];\n\n\t\thelpers.forEach(relations, function(rel){\n\t\t\tif(rel.target == rel.source)\n\t\t\t\tcycles.push([rel.target, rel.source]);\n\t\t});\n\n\t\tvar graph =  gantt._autoSchedulingGraph;\n\t\tvar vertices = graph.getVertices(relations);\n\n\t\tvar connectedComponents = graph.tarjanStronglyConnectedComponents(vertices, relations);\n\n\t\thelpers.forEach(connectedComponents, function(component){\n\t\t\tif(component.tasks.length > 1){\n\t\t\t\tcycles.push(component);//{ tasks: [task ids], links: [links ids]}\n\t\t\t}\n\t\t});\n\n\t\treturn cycles;\n\t\t//{task:id, link:link.type, lag: link.lag || 0, source: link.source}\n\t}\n};\n\ngantt._autoSchedulingDateResolver = {\n\tisFirstSmaller: function(small, big, task){\n\t\tif(small.valueOf() < big.valueOf() && gantt._hasDuration(small, big, task))\n\t\t\treturn true;\n\t\treturn false;\n\t},\n\n\tisSmallerOrDefault: function(smallDate, bigDate, task){\n\t\treturn !!(!smallDate || this.isFirstSmaller(smallDate, bigDate, task));\n\t},\n\n\tresolveRelationDate: function(taskId, relations, getEndDate){\n\t\tvar minStart = null;\n\t\tvar linkId = null;\n\n\t\tvar defaultStart = null;\n\n\t\tfor(var i = 0; i < relations.length; i++){\n\t\t\tvar relation = relations[i];\n\t\t\ttaskId = relation.target;\n\n\t\t\tdefaultStart = relation.preferredStart;\n\n\t\t\tvar constraintDate = this.getConstraintDate(relation, getEndDate);\n\n\t\t\tif(this.isSmallerOrDefault(defaultStart, constraintDate, gantt.getTask(taskId)) && this.isSmallerOrDefault(minStart, constraintDate, gantt.getTask(taskId))){\n\t\t\t\tminStart = constraintDate;\n\t\t\t\tlinkId = relation.id;\n\t\t\t}\n\n\t\t}\n\n\t\tif(minStart){\n\t\t\tminStart = gantt.getClosestWorkTime({date:minStart, dir:\"future\", task:gantt.getTask(taskId)});\n\t\t}\n\n\t\treturn {\n\t\t\tlink: linkId,\n\t\t\ttask: taskId,\n\t\t\tstart_date: minStart\n\t\t};\n\t},\n\tgetConstraintDate: function(relation, getEndDate){\n\t\tvar predecessorEnd = getEndDate(relation.source);\n\t\tvar successor = gantt.getTask(relation.target);\n\n\t\tvar successorStart = gantt.getClosestWorkTime({date:predecessorEnd, dir:\"future\", task:successor});\n\n\t\tif(predecessorEnd && relation.lag && relation.lag*1 == relation.lag){\n\t\t\tsuccessorStart = gantt.calculateEndDate({start_date: predecessorEnd, duration: relation.lag*1, task: successor});\n\t\t}\n\n\t\treturn successorStart;\n\t}\n};\n\ngantt._autoSchedulingPlanner = {\n\tgeneratePlan: function(relations){\n\n\t\tvar graph = gantt._autoSchedulingGraph;\n\t\tvar orderedIds = graph.topologicalSort(relations);\n\t\tvar predecessorRelations = {},\n\t\t\tplansHash = {};\n\n\t\thelpers.arrayMap(orderedIds, function(v) {\n\t\t\tvar task = gantt.getTask(v);\n\t\t\tif(task.auto_scheduling === false){\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpredecessorRelations[v] = [];\n\t\t\tplansHash[v] = null;\n\t\t});\n\n\t\tfunction getPredecessorEndDate(id){\n\t\t\tvar plan = plansHash[id];\n\t\t\tvar task = gantt.getTask(id);\n\t\t\tvar res;\n\n\t\t\tif(!(plan && (plan.start_date || plan.end_date))){\n\t\t\t\tres = task.end_date;\n\t\t\t}else if(plan.end_date){\n\t\t\t\tres = plan.end_date;\n\t\t\t}else {\n\t\t\t\tres = gantt.calculateEndDate({start_date: plan.start_date, duration: task.duration, task: task});\n\t\t\t}\n\n\t\t\treturn res;\n\t\t}\n\n\t\tfor(var i = 0; i < relations.length; i++){\n\t\t\tif(predecessorRelations[relations[i].target]) {\n\t\t\t\tpredecessorRelations[relations[i].target].push(relations[i]);\n\t\t\t}\n\t\t}\n\n\t\tvar dateResolver = gantt._autoSchedulingDateResolver;\n\n\t\tvar result = [];\n\t\tfor(var i = 0; i < orderedIds.length; i++){\n\t\t\tvar currentId = orderedIds[i];\n\n\t\t\tvar plan = dateResolver.resolveRelationDate(currentId, predecessorRelations[currentId] || [], getPredecessorEndDate);\n\n\n\t\t\tif(plan.start_date && gantt.isLinkExists(plan.link)){\n\t\t\t\tvar link = gantt.getLink(plan.link);\n\t\t\t\tvar task = gantt.getTask(currentId);\n\t\t\t\tvar predecessor = gantt.getTask(link.source);\n\n\t\t\t\tif (task.start_date.valueOf() !== plan.start_date.valueOf() && gantt.callEvent(\"onBeforeTaskAutoSchedule\", [task, plan.start_date, link, predecessor]) === false) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplansHash[currentId] = plan;\n\t\t\tif(plan.start_date){\n\t\t\t\tresult.push(plan);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\tapplyProjectPlan: function(projectPlan){\n\t\tvar plan, task, link, predecessor;\n\n\t\tvar updateTasks = [];\n\t\tfor(var i = 0; i <  projectPlan.length; i++){\n\t\t\tlink = null;\n\t\t\tpredecessor = null;\n\t\t\tplan = projectPlan[i];\n\n\t\t\tif(!plan.task) continue;\n\n\t\t\ttask = gantt.getTask(plan.task);\n\t\t\tif(plan.link){\n\t\t\t\tlink = gantt.getLink(plan.link);\n\t\t\t\tpredecessor = gantt.getTask(link.source);\n\t\t\t}\n\n\t\t\tvar newDate = null;\n\t\t\tif(plan.start_date && (task.start_date.valueOf() != plan.start_date.valueOf())){\n\t\t\t\tnewDate = plan.start_date;\n\t\t\t}\n\n\t\t\tif(!newDate) continue;\n\t\t\t\n\t\t\ttask.start_date = newDate;\n\t\t\ttask.end_date = gantt.calculateEndDate(task);\n\n\t\t\tupdateTasks.push(task.id);\n\t\t\tgantt.callEvent(\"onAfterTaskAutoSchedule\", [task, newDate, link, predecessor]);\n\n\t\t}\n\t\treturn updateTasks;\n\t}\n};\n\ngantt._autoSchedulingPreferredDates = function(startTask, relations){\n\tfor(var i = 0; i < relations.length; i++){\n\t\tvar rel = relations[i];\n\t\tvar task = gantt.getTask(rel.target);\n\n\t\tif(!gantt.config.auto_scheduling_strict || rel.target == startTask){\n\t\t\trel.preferredStart = new Date(task.start_date);\n\t\t}\n\t}\n};\n\ngantt._autoSchedule = function(id, relations, updateCallback){\n\tif (gantt.callEvent(\"onBeforeAutoSchedule\", [id]) === false) {\n\t\treturn;\n\t}\n\tgantt._autoscheduling_in_progress = true;\n\n\tvar path = gantt._autoSchedulingPath;\n\n\tvar updatedTasks = [];\n\n\tvar cycles = path.findLoops(relations);\n\tif(cycles.length){\n\t\tgantt.callEvent(\"onAutoScheduleCircularLink\", [cycles]);\n\t}else{\n\n\t\tvar planner = gantt._autoSchedulingPlanner;\n\t\tgantt._autoSchedulingPreferredDates(id, relations);\n\n\t\tvar plan = planner.generatePlan(relations);\n\t\tupdatedTasks = planner.applyProjectPlan(plan);\n\n\t\tif(updateCallback){\n\t\t\tupdateCallback(updatedTasks);\n\t\t}\n\t}\n\n\tgantt._autoscheduling_in_progress = false;\n\tgantt.callEvent(\"onAfterAutoSchedule\", [id, updatedTasks]);\n\n\treturn updatedTasks;\n};\n\ngantt.autoSchedule = function(id, inclusive){\n\n\tif(inclusive === undefined){\n\t\tinclusive = true;\n\t}else{\n\t\tinclusive = !!inclusive;\n\t}\n\tvar relations =  gantt._autoSchedulingPath.getLinkedTasks(id, inclusive);\n\tgantt._autoSchedule(id, relations, gantt._finalizeAutoSchedulingChanges);\n};\n\ngantt._finalizeAutoSchedulingChanges = function(updatedTasks){\n\tfunction resetTime(task){\n\t\tif(batchUpdate)\n\t\t\treturn;\n\n\t\tvar start = task.start_date.valueOf(),\n\t\t\tend = task.end_date.valueOf();\n\n\t\tgantt.resetProjectDates(task);\n\t\tif(task.start_date.valueOf() != start || task.end_date.valueOf() != end){\n\t\t\tbatchUpdate = true;\n\t\t\treturn;\n\t\t}\n\t\tvar children = gantt.getChildren(task.id);\n\t\tfor(var i = 0; !batchUpdate && i < children.length; i++){\n\t\t\tresetTime(gantt.getTask(children[i]));\n\t\t}\n\t}\n\n\tvar batchUpdate = false;\n\t// call batchUpdate (full repaint) only if we update multiple tasks,\n\tif(updatedTasks.length == 1){\n\t\tgantt.eachParent(resetTime, updatedTasks[0]);\n\t}else if(updatedTasks.length){\n\t\tbatchUpdate = true;\n\t}\n\n\tfunction payload(){\n\t\tfor(var i = 0; i < updatedTasks.length; i++){\n\t\t\tgantt.updateTask(updatedTasks[i]);\n\t\t}\n\t}\n\tif(batchUpdate){\n\t\tgantt.batchUpdate(payload);\n\t}else{\n\t\tpayload();\n\t}\n\n};\n\ngantt.isCircularLink = function(link){\n\treturn !!gantt._getConnectedGroup(link);\n\n};\n\ngantt._getConnectedGroup = function(link){\n\tvar manager = gantt._autoSchedulingPath;\n\n\tvar allRelations = manager.getLinkedTasks();\n\tif(!gantt.isLinkExists(link.id)){\n\t\tallRelations = allRelations.concat(gantt._formatLink(link));\n\t}\n\n\tvar cycles = manager.findLoops(allRelations);\n\n\tvar found = false;\n\tfor(var i = 0; (i < cycles.length) && !found; i++){\n\t\tvar links = cycles[i].links;\n\t\tfor(var j = 0; j < links.length; j++){\n\t\t\tif(links[j] == link.id){\n\t\t\t\treturn cycles[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n};\n\ngantt.findCycles = function(){\n\tvar manager = gantt._autoSchedulingPath;\n\n\tvar allRelations = manager.getLinkedTasks();\n\treturn manager.findLoops(allRelations);\n};\n\ngantt._attachAutoSchedulingHandlers = function(){\n\n\tgantt._autoScheduleAfterLinkChange = function (linkId, link) {\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\n\t\t\tgantt.autoSchedule(link.source);\n\t\t}\n\t};\n\n\tgantt.attachEvent(\"onAfterLinkUpdate\", gantt._autoScheduleAfterLinkChange);\n\tgantt.attachEvent(\"onAfterLinkAdd\", gantt._autoScheduleAfterLinkChange);\n\n\tgantt.attachEvent(\"onAfterLinkDelete\", function(id, link){\n\t\tif (this.config.auto_scheduling && !this._autoscheduling_in_progress && this.isTaskExists(link.target)) {\n\t\t\t// after link deleted - auto schedule target for other relations that may be left\n\t\t\tvar target = this.getTask(link.target);\n\t\t\tvar predecessors = this._getPredecessors(target);\n\t\t\tif(predecessors.length){\n\t\t\t\tthis.autoSchedule(predecessors[0].source, false);\n\t\t\t}\n\t\t}\n\t});\n\n\tgantt.attachEvent(\"onParse\", function(){\n\t\tif (gantt.config.auto_scheduling && gantt.config.auto_scheduling_initial) {\n\t\t\tgantt.autoSchedule();\n\t\t}\n\t});\n\n\tgantt._preventCircularLink = function(id, link){\n\t\tif(gantt.isCircularLink(link)){\n\t\t\tgantt.callEvent(\"onCircularLinkError\", [link, gantt._getConnectedGroup(link)]);\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t};\n\n\tgantt._preventDescendantLink = function(id, link){\n\t\tvar source = gantt.getTask(link.source),\n\t\t\ttarget = gantt.getTask(link.target);\n\n\t\tif(!gantt.config.auto_scheduling_descendant_links){\n\t\t\tif((gantt.isChildOf(source.id, target.id) && gantt.isSummaryTask(target)) || (gantt.isChildOf(target.id, source.id) && gantt.isSummaryTask(source))){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\tgantt.attachEvent(\"onBeforeLinkAdd\", gantt._preventCircularLink);\n\tgantt.attachEvent(\"onBeforeLinkAdd\", gantt._preventDescendantLink);\n\tgantt.attachEvent(\"onBeforeLinkUpdate\", gantt._preventCircularLink);\n\tgantt.attachEvent(\"onBeforeLinkUpdate\", gantt._preventDescendantLink);\n\n\tgantt._datesNotEqual = function(dateA, dateB, taskA, taskB){\n\t\tif(dateA.valueOf() > dateB.valueOf()){\n\t\t\treturn this._hasDuration({start_date: dateB, end_date: dateA, task: taskB});\n\t\t}else{\n\t\t\treturn this._hasDuration({start_date: dateA, end_date: dateB, task: taskA});\n\t\t}\n\t};\n\tgantt._notEqualTaskDates = function(task1, task2){\n\t\tif (this._datesNotEqual(task1.start_date, task2.start_date, task1, task2) ||\n\t\t\t((this._datesNotEqual(task1.end_date, task2.end_date, task1, task2) ||\n\t\t\t\ttask1.duration != task2.duration) && task1.type != gantt.config.types.milestone)) {\n\t\t\treturn true;\n\t\t}\n\t};\n\n\tvar relations;\n\tvar movedTask;\n\tgantt.attachEvent(\"onBeforeTaskDrag\", function(id, mode, task){\n\t\tif(gantt.config.auto_scheduling_move_projects){\n\t\t\t// collect relations before drag and drop  in order to have original positions of subtasks within project since they are used as lag when moving dependent project\n\t\t\trelations = gantt._autoSchedulingPath.getLinkedTasks(id, true);\n\t\t\tmovedTask = id;\n\t\t}\n\t\treturn true;\n\t});\n\n\tfunction resetToStartLinksLags(taskId, relations){\n\t\tvar skipped = false;\n\t\tfor(var i = 0; i < relations.length; i++){\n\t\t\tvar originalLink = gantt.getLink(relations[i].id);\n\t\t\tif(originalLink.type == gantt.config.links.start_to_start || originalLink.type == gantt.config.links.start_to_finish){\n\t\t\t\trelations.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t\tskipped = true;\n\t\t\t}\n\t\t}\n\n\t\tif(skipped){\n\t\t\tvar presentLinks = {};\n\t\t\tfor(var i = 0; i < relations.length; i++){\n\t\t\t\tpresentLinks[relations[i].id] = true;\n\t\t\t}\n\n\t\t\tvar updatedLinks = gantt._autoSchedulingPath.getLinkedTasks(taskId, true);\n\t\t\tfor(var i = 0; i < updatedLinks.length; i++){\n\t\t\t\tif(!presentLinks[updatedLinks[i].id]){\n\t\t\t\t\trelations.push(updatedLinks[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgantt._autoScheduleAfterDND = function(taskId, task){\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\n\t\t\tvar newTask = this.getTask(taskId);\n\t\t\tif (gantt._notEqualTaskDates(task, newTask)){\n\t\t\t\tif(gantt.config.auto_scheduling_move_projects && movedTask == taskId){\n\n\t\t\t\t\tif(gantt.calculateDuration(task) != gantt.calculateDuration(newTask)){\n\t\t\t\t\t\t// task duration is used as lag when converting start_to_start and start_to_finish into finish to start links\n\t\t\t\t\t\t// recalculate these links if task duration has changed\n\t\t\t\t\t\tresetToStartLinksLags(taskId, relations);\n\t\t\t\t\t}\n\n\n\t\t\t\t\tgantt._autoSchedule(taskId, relations, gantt._finalizeAutoSchedulingChanges);\n\t\t\t\t}else{\n\t\t\t\t\tgantt.autoSchedule(newTask.id);\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t}\n\t\trelations = null;\n\t\tmovedTask = null;\n\t\treturn true;\n\t};\n\n\tgantt._lightBoxChangesHandler = function (taskId, task) {\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\n\t\t\tvar oldTask = this.getTask(taskId);\n\t\t\tif (gantt._notEqualTaskDates(task, oldTask)) {\n\t\t\t\tgantt._autoschedule_lightbox_id = taskId;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\tgantt._lightBoxSaveHandler = function (taskId, task) {\n\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\n\t\t\tif (gantt._autoschedule_lightbox_id && gantt._autoschedule_lightbox_id == taskId) {\n\t\t\t\tgantt._autoschedule_lightbox_id = null;\n\t\t\t\tgantt.autoSchedule(task.id);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\n\n\n\tgantt.attachEvent(\"onBeforeTaskChanged\", function(id, mode, task){ return gantt._autoScheduleAfterDND(id, task); });\n\tgantt.attachEvent(\"onLightboxSave\", gantt._lightBoxChangesHandler);\n\tgantt.attachEvent(\"onAfterTaskUpdate\", gantt._lightBoxSaveHandler);\n\n\n};\n\n\ngantt.attachEvent(\"onGanttReady\", function(){\n\tgantt._attachAutoSchedulingHandlers();\n\t// attach handlers only when initialized for the first time\n\tgantt._attachAutoSchedulingHandlers = function(){};\n});\n\n})();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/ext/auto_scheduling.js\n// module id = 3\n// module chunks = 1","var units = {\n\t\"second\": 1,\n\t\"minute\": 60,\n\t\"hour\": 60 * 60,\n\t\"day\": 60 * 60 * 24,\n\t\"week\": 60 * 60 * 24 * 7,\n\t\"month\": 60 * 60 * 24 * 30,\n\t\"quarter\": 60 * 60 * 24 * 30 * 3,\n\t\"year\": 60 * 60 * 24 * 365\n};\nfunction getSecondsInUnit(unit){\n\treturn units[unit] || units.hour;\n}\n\nfunction forEach(arr, callback){\n\tvar workArray = arr.slice();\n\tfor(var i = 0; i < workArray.length; i++){\n\t\tcallback(workArray[i], i);\n\t}\n}\n\nfunction arrayMap(arr, callback){\n\tvar workArray = arr.slice();\n\tvar resArray = [];\n\n\tfor(var i = 0; i < workArray.length; i++){\n\t\tresArray.push(callback(workArray[i], i));\n\t}\n\n\treturn resArray;\n}\n\nmodule.exports = {\n\tgetSecondsInUnit: getSecondsInUnit,\n\tforEach: forEach,\n\tarrayMap: arrayMap\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/utils/helpers.js\n// module id = 4\n// module chunks = 1"],"sourceRoot":""}